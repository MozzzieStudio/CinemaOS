/**
 * Visual Bible Export ‚Äî PDF Generation for Tokens
 * 
 * Exports all tokens with their visuals as a production-ready PDF.
 */

import jsPDF from 'jspdf';
import type { Token, TokenType } from '../types/tokens';

const TOKEN_TYPE_COLORS: Record<TokenType, [number, number, number]> = {
  Character: [139, 92, 246],   // Purple
  Location: [16, 185, 129],    // Green
  Prop: [245, 158, 11],        // Amber
  Set: [59, 130, 246],         // Blue
};

const TOKEN_TYPE_ICONS: Record<TokenType, string> = {
  Character: 'üë§',
  Location: 'üìç',
  Prop: 'üé¨',
  Set: 'üé≠',
};

interface VisualBibleOptions {
  title?: string;
  projectName?: string;
  includeMetadata?: boolean;
  includeVisuals?: boolean;
}

export async function generateVisualBible(
  tokens: Token[],
  options: VisualBibleOptions = {}
): Promise<Blob> {
  const {
    title = 'Visual Bible',
    projectName = 'Cinema OS Project',
    includeMetadata = true,
    includeVisuals = true,
  } = options;

  const pdf = new jsPDF('p', 'pt', 'letter');
  const pageWidth = pdf.internal.pageSize.getWidth();
  const pageHeight = pdf.internal.pageSize.getHeight();
  const margin = 50;
  let yPosition = margin;

  // Helper to add new page if needed
  const checkNewPage = (requiredHeight: number) => {
    if (yPosition + requiredHeight > pageHeight - margin) {
      pdf.addPage();
      yPosition = margin;
      return true;
    }
    return false;
  };

  // Title Page
  pdf.setFontSize(32);
  pdf.setFont('helvetica', 'bold');
  pdf.text(title, pageWidth / 2, 200, { align: 'center' });
  
  pdf.setFontSize(16);
  pdf.setFont('helvetica', 'normal');
  pdf.text(projectName, pageWidth / 2, 240, { align: 'center' });
  
  pdf.setFontSize(12);
  pdf.setTextColor(128, 128, 128);
  pdf.text(`Generated: ${new Date().toLocaleDateString()}`, pageWidth / 2, 280, { align: 'center' });
  pdf.text(`Total Tokens: ${tokens.length}`, pageWidth / 2, 300, { align: 'center' });
  
  pdf.setTextColor(0, 0, 0);

  // Group tokens by type
  const tokensByType: Record<TokenType, Token[]> = {
    Character: [],
    Location: [],
    Prop: [],
    Set: [],
  };

  tokens.forEach(token => {
    tokensByType[token.token_type].push(token);
  });

  // Generate sections for each type
  const types: TokenType[] = ['Character', 'Location', 'Prop', 'Set'];
  
  for (const type of types) {
    const typeTokens = tokensByType[type];
    if (typeTokens.length === 0) continue;

    // New page for each section
    pdf.addPage();
    yPosition = margin;

    // Section Header
    const color = TOKEN_TYPE_COLORS[type];
    pdf.setFillColor(color[0], color[1], color[2]);
    pdf.rect(margin, yPosition, pageWidth - margin * 2, 40, 'F');
    
    pdf.setFontSize(18);
    pdf.setFont('helvetica', 'bold');
    pdf.setTextColor(255, 255, 255);
    pdf.text(`${TOKEN_TYPE_ICONS[type]} ${type}s (${typeTokens.length})`, margin + 15, yPosition + 27);
    
    pdf.setTextColor(0, 0, 0);
    yPosition += 60;

    // Token entries
    for (const token of typeTokens) {
      checkNewPage(150);

      // Token Card
      pdf.setDrawColor(200, 200, 200);
      pdf.setFillColor(250, 250, 250);
      const cardHeight = includeMetadata ? 120 : 80;
      pdf.roundedRect(margin, yPosition, pageWidth - margin * 2, cardHeight, 5, 5, 'FD');

      // Token Name
      pdf.setFontSize(14);
      pdf.setFont('helvetica', 'bold');
      pdf.setTextColor(color[0], color[1], color[2]);
      pdf.text(token.name, margin + 15, yPosition + 25);

      // Description
      pdf.setFontSize(10);
      pdf.setFont('helvetica', 'normal');
      pdf.setTextColor(80, 80, 80);
      const descLines = pdf.splitTextToSize(token.description || 'No description', pageWidth - margin * 2 - 30);
      pdf.text(descLines.slice(0, 2), margin + 15, yPosition + 45);

      // Metadata
      if (includeMetadata && Object.keys(token.metadata).length > 0) {
        let metaY = yPosition + 70;
        pdf.setFontSize(8);
        pdf.setTextColor(120, 120, 120);
        
        for (const [key, value] of Object.entries(token.metadata).slice(0, 3)) {
          pdf.text(`${key}: ${value}`, margin + 15, metaY);
          metaY += 12;
        }
      }

      // Visual indicator
      if (includeVisuals && token.visual_refs.length > 0) {
        pdf.setFontSize(8);
        pdf.setTextColor(16, 185, 129);
        pdf.text(`${token.visual_refs.length} visual(s)`, pageWidth - margin - 60, yPosition + 25);
      }

      yPosition += cardHeight + 15;
    }
  }

  // Footer on last page
  pdf.setFontSize(8);
  pdf.setTextColor(128, 128, 128);
  pdf.text('Generated by Cinema OS', pageWidth / 2, pageHeight - 30, { align: 'center' });

  return pdf.output('blob');
}

export async function downloadVisualBible(tokens: Token[], filename?: string): Promise<void> {
  const blob = await generateVisualBible(tokens);
  const url = URL.createObjectURL(blob);
  const link = document.createElement('a');
  link.href = url;
  link.download = filename || `visual-bible-${new Date().toISOString().split('T')[0]}.pdf`;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}
